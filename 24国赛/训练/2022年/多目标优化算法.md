# 多目标优化算法

## 求解方法

https://tech.uupt.com/?p=1215

## 智能优化算法

https://www.lishengxie.top/index.php/archives/82/

### 遗传算法NSGA

https://blog.csdn.net/qq_20412595/article/details/129457083

``` python
from deap import base, creator, tools, algorithms
import random

# 定义多目标适应度类（最小化两个目标）
creator.create("FitnessMulti", base.Fitness, weights=(-1.0, -1.0))
creator.create("Individual", list, fitness=creator.FitnessMulti)

# 目标函数示例
def evaluate(individual):
    x1, x2 = individual
    return x1**2 + x2**2, (x1 - 1)**2 + (x2 - 1)**2

# 初始化工具箱
toolbox = base.Toolbox()
toolbox.register("attr_float", random.uniform, -5, 5)
toolbox.register("individual", tools.initCycle, creator.Individual, (toolbox.attr_float, toolbox.attr_float), n=1)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)
toolbox.register("evaluate", evaluate)
toolbox.register("mate", tools.cxBlend, alpha=0.5)
toolbox.register("mutate", tools.mutPolynomialBounded, low=-5, up=5, eta=0.5, indpb=0.2)
toolbox.register("select", tools.selNSGA2)

# 创建初始种群
population = toolbox.population(n=100)

# 设置算法参数
cxpb, mutpb, ngen = 0.7, 0.3, 40

# 运行 NSGA-II 算法
for gen in range(ngen):
    # 评估所有个体的适应度
    fitnesses = map(toolbox.evaluate, population)
    for ind, fit in zip(population, fitnesses):
        ind.fitness.values = fit

    # 选择操作
    offspring = toolbox.select(population, len(population))
    offspring = list(map(toolbox.clone, offspring))

    # 交叉和变异
    for child1, child2 in zip(offspring[::2], offspring[1::2]):
        if random.random() < cxpb:
            toolbox.mate(child1, child2)
            del child1.fitness.values
            del child2.fitness.values

    for mutant in offspring:
        if random.random() < mutpb:
            toolbox.mutate(mutant)
            del mutant.fitness.values

    # 合并当前种群和子代
    population[:] = toolbox.select(population + offspring, len(population))

# 打印结果
for ind in population:
    print(ind.fitness.values)

```



